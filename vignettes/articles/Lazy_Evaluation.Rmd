---
title: "Lazy Evaluation"
author: "Mazama Science"
date: "2020-07-03"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Lazy Evaluation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  message = FALSE,
  fig.width = 7, 
  fig.height = 5
)
```

This vignette will introduce the concept of lazy evaluation and how it is useful
for working with the large data sets handled by the AirFireModeling package.

## Lazy Evaluation
'Lazy evaluation' is an evaluation strategy in programming that is centered on 
procrastination. When an expression is encountered in a program using this 
strategy, the calculation of that expression is postponed until its value is 
required elsewhere (which might never happen). Lazy evaluation is typically 
found in functional programming languages such as Haskell and R, and contrasts 
the 'eager evaluation' strategy common to most imperative languages like C++, 
Java, and Python.

To demonstrate the difference, consider the following code:
```
1   x <- 1 + 2
2   print(x)
```
An 'eager' approach:

1. Calculate `1 + 2` to get 3 and assign 3 to `x`.
2. Retrieve the value of `x` and print it out.

A 'lazy' approach:

1. Remember the expression `1 + 2` assigned to `x`.
2. The value of `x` is needed here! Now calculate its expression, assign the 
result to `x`, and then print the value of `x`.

While the difference is negligible in this example, the benefits of lazy 
evaluation can become apparent when expressions become large and complex. The
lazy strategy can greatly improve performance and reduce a program's memory
footprint by creating values only when they are actually needed. However, this 
can come at the cost of increased overhead and loss of control.

[Wikipedia](https://en.wikipedia.org/wiki/Lazy_evaluation)

[About Lazy Evaluation](https://www.r-bloggers.com/about-lazy-evaluation/)

[Lazy Evaluation in a Strict Language](https://medium.com/javascript-in-plain-english/lazy-evaluation-in-a-strict-language-a8f938870a7a)

## NetCDF
Lazy evaluation is useful when it comes to working with netCDF data. NetCDF
(network Common Data Format) is a file format designed around the creation, 
access, and sharing of large array-based data sets. It is commonly used in 
geospatial applications like meteorology, climatology, and oceanography, but is
also useful in many other fields.

NetCDF data is:

* Self-describing, meaning that it includes information about the data it 
contains such as its grid layout and the names and units of its variables.

* Portable, so that a netCDF file created on one operating system can be 
transferred and readable to a machine running a different operating system.

* Scalable, such that a small subset of a large netCDF file can be accessed 
efficiently without reading the entire contents of the file.

Efficiency is a primary concern when working with netCDF files since they often 
contain enormous amounts of information and can therefore take time to load and 
large portions of RAM to store. It is important then to read/write *only* what 
is necessary *only* when required. The `ncdf4` package in R achieves this 
efficiency by providing an interface for a netCDF file which loads as little 
data as possible until queried for specific variables.

To illustrate this, `ncdf4` supplies the `nc_open` function which "opens" a
netCDF file for reading/writing. Its output is an object which contains just the
file metadata, therefore describing its contents without loading its actual 
readings. These can be accessed after opening the file through a call to 
`ncvar_get` requesting a desired variable.

[ncdf4 package](https://cran.r-project.org/web/packages/ncdf4/ncdf4.pdf)

## Raster
Rasters are often used to represent the gridded information stored in netCDF 
files. Multiple raster objects can be layered on top one another to   

[raster package](https://cran.r-project.org/web/packages/raster/raster.pdf)

### Lazy Evaluation in Rasters
(Using raster package only functions from the example I pasted into Slack.)

```{r raster_example}
v2FilePath <- "~/Data/BlueSky/PNW-4km_2019100900_v2.nc"
rasterBrick <- raster::brick(v2FilePath)

rasterSize <- pryr::object_size(rasterBrick)
fileBytes <- file.info(v2FilePath)$size
fileSize <- utils:::format.object_size(fileBytes, "auto")

print(paste("File size:", fileSize, "\nRaster size:", rasterSize))
```

## AirFireModeling

The `AirFireModeling` package can turn the netCDF files output by BlueSky model 
runs into RasterBricks for visualization. These model run files typically range 
from a few dozen megabytes to several hundred, so it is important for us to 
consider how lazy evaluation factors into working with this data efficiently.

### Lazy Evaluation in AirFireModeling
The `bluesky_load` function provides an easy way to load in a specified Bluesky
model run. It returns a RasterBrick as output, so from then on the same lazy 
evaluation occurs as it does for a Raster object like we have just seen.

```{r afm_example}
library(AirFireModeling) # For base package support
setModelDataDir("~/Data/BlueSky")

originalRaster <- bluesky_load("PNW-4km", 2019100900)

editedRaster <- originalRaster * 1
dim(originalRaster@data@values)
dim(editedRaster@data@values)

print(pryr::object_size(originalRaster))
originalRaster@data@inmemory
originalRaster@data@fromdisk

pryr::object_size(editedRaster)
editedRaster@data@inmemory
editedRaster@data@fromdisk
```

### Optimization
Discussion of the importance of using xlim and ylim parameters to bluesky_load().

### Example 2
Perhaps use the example in raster_toMonitor() with shadedNight = TRUE and better labeling.

```{r optimization_example}
# Load model data
rasterList <- raster_load(
  modelName = c("PNW-1.33km", "PNW-4km"),
  modelRun = c(2019100900),
  xlim = c(-125, -115),
  ylim = c(42, 50)
)

# MazamaSpatialUtils are needed to determine timezone and state
library(MazamaSpatialUtils)
PWFSLSmoke::initializeMazamaSpatialUtils()

model_Portland <- raster_toMonitor(
  rasterList,
  longitude = -122.68,
  latitude = 45.52,
  radius = 5
)

PWFSLSmoke::monitor_timeseriesPlot(
  model_Portland[[1]],
  type = 'l', col = 'salmon'
)

PWFSLSmoke::monitor_timeseriesPlot(
  model_Portland[[2]],
  type = 'l', col = 'dodgerblue', add = TRUE
)
```
