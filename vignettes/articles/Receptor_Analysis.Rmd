---
title: "Receptor Analysis"
author: "Mazama Science"
date: "2020-07-08"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Receptor_Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  message = FALSE,
  fig.width = 7, 
  fig.height = 5
)
```

This vignette explains how "receptor analysis" reports are generated. These
reports gather and visualize PM 2.5 readings for a given location using
BlueSky model output.

## Report Parameters

Before anything else, a report must gather all the details about the analysis 
being requested. These are provided in the `infoList`, `dataList`, and 
`textList` parameters, which hold useful information like the coordinates of the
target location, start/end dates, and the sample radius around the location.

## Header & Map

The report header displays the time the report was requested as well as the 
versions of the packages it uses: **PWFSLSmoke** and **AirFireModeling**.
This information is gathered using `lubridate::now()` and 
`utils::packageVersion()`.

For example:

* `lubridate::now()`: `r lubridate::now()`

* `utils::packageVersion("AirFireModeling")`: `r utils::packageVersion("AirFireModeling")`

A simple Leaflet map is displayed under the header with a marker at the 
location of interest.

## Latest Available Models

Now the PM 2.5 readings around the target location will be gathered. The first 
step towards this is to determine which BlueSky models have a domain covering 
that particular location. The **AirFireModeling** package provides an easy way 
to do this with the `bluesky_findModels()` function, which takes in longitude 
and latitude coordinates and returns a list of the models that cover them:

```{r finding_models}
library(AirFireModeling)
setModelDataDir('~/Data/BlueSky')

# Rough coordinates of Los Angeles
longitude <- -118
latitude <- 34

# Models covering Los Angeles
availableModels <- bluesky_findModels(longitude, latitude)
```

Reports are further limited to only using a small subset of these models:

* PNW-4km
* PNW-1.33km
* CANSAC-4km
* CANSAC-1.33km

```{r subset_models}
allowedModels <- c(
  "PNW-4km", "PNW-1.33km",
  "CANSAC-4km", "CANSAC-1.33km"
)

modelNames <- intersect(availableModels, allowedModels)
```

With the proper models for that location, the latest two runs for each model 
are loaded using `bluesky_latestModelRun()`:

```{r}
# Load the latest two runs for the chosen models
latestModelRuns <- bluesky_latestModelRun(modelName = modelNames, count = 2)
```

Lastly, each of these model runs are displayed in a table with links to their 
animations on the
[BlueSky Daily Run Viewer](https://www.google.com/url?q=https%3A%2F%2Ftools.airfire.org%2Fwebsky%2F&sa=D&sntz=1&usg=AFQjCNGckuTjB3h9DCJBigyWwB49FEkryA) provided as well.

## Loading Model Runs

Once the model runs have been identified for the location, the actual data 
produced by those runs must be loaded.

Each BlueSky model covers a sizable area--from the entire continental U.S. to 
large portions of individual states. An analysis report, however, is only 
concerned with a specific location and its close surroundings. To avoid loading 
more data than necessary and wasting time and memory, a rectangular boundary is 
calculated around the target location and only the data in that area is 
gathered. The longitude and latitude limits of this boundary are determined by 
the sample radius parameter like so:

```{r calculate_load_boundary}
radius <- 10 # 10km around the location

# 111320 m per deg at the equator 
halfWidth <- radius / 111.320
xlim <- c(longitude - 2 * halfWidth, longitude + 2 * halfWidth)
ylim <- c(latitude - 2 * halfWidth, latitude + 2 * halfWidth)
```

In this case:

* Min/max longitude: `r formatC(xlim, digits = 2, format = "f")`

* Min/max latitude: `r formatC(ylim, digits = 2, format = "f")`

The previously selected model runs are then loaded in using `bluesky_load()` 
with the `xlim` and `ylim` boundaries:

```{r load_model_run}
modelRuns <- AirFireModeling::bluesky_load(
  modelName = modelNames,
  modelRun = latestModelRuns,
  xlim = xlim,
  ylim = ylim,
  verbose = FALSE
)

class(modelRuns)
```

## Conversion to Monitor

The data loaded from a BlueSky model run provides a set of gridded PM 2.5 
readings in the form of a _RasterBrick_. The goal of a receptor analysis report 
is to use this data to produce timeseries plots of PM 2.5 readings around a
target location, so it is necessary to transform RasterBricks into a form
that is timeseries plottable. This is can be done using the `raster_toMonitor()`
function, which creates a PWFSLSmoke _ws_monitor_ object from a _Raster_ object.
This requires the coordinates of the target location as well as the sample 
radius around it and an upper limit on the number of cells that can be sampled
for this 'fake monitor'.

```{r monitor_conversion}
# MazamaSpatialUtils are needed to determine timezone and state
library(MazamaSpatialUtils)
PWFSLSmoke::initializeMazamaSpatialUtils()

count <- 20 # Sample at most 20 grid cells around the location

fakeMonitors <- AirFireModeling::raster_toMonitor(
  modelRuns,
  longitude = longitude,
  latitude = latitude,
  radius = radius,
  count = count,
  verbose = FALSE
)

class(fakeMonitors)
```

## Timeseries Plots

Timeseries plots for monitors are generated with the `ggplot_pm25Timeseries()` 
function from the **AirMonitorPlots** package. Monitor PM 2.5 readings are 
subset by the start/end date parameters, then drawn onto two visualizations: 
The first plots PM 2.5 readings separated by model and colored by model run, and
the second plots PM 2.5 readings separated by model run and colored by model:

```{r plot_timeseries, echo=FALSE}
library(PWFSLSmoke)
library(AirMonitorPlots)

# Latest model runs
latestModelRunList <- list()
for ( model in modelNames ) {
  latestModelRunList[[model]] <- bluesky_latestModelRun(model, 2)
}

# Old school creation of a dataframe
modelNameList <- list()
modelRunList <- list()
i <- 1
for ( name in modelNames ) {
  for ( run in latestModelRunList[[name]] ) {
    modelNameList[[i]] <- name
    modelRunList[[i]] <- run
    i <- i + 1
  }
}

modelName <- as.character(unlist(modelNameList))
modelRun <- as.character(unlist(modelRunList))
modelRunTime <- MazamaCoreUtils::parseDatetime(modelRun, timezone = "UTC")
modelRunTimeString <- strftime(modelRunTime, "%a, %B %e at %H:00 UTC", tz = "UTC")
webskyUrl <- paste0("https://tools.airfire.org/websky/v1/run/standard/", modelName, "/", modelRun)
modelNameUrl <- paste0("[", modelName, "](", webskyUrl, ")")

# Create a dataframe for later use
modelDF <- data.frame(
  modelName = modelName,
  modelRun = modelRun,
  modelRunTime = modelRunTime,
  stringsAsFactors = FALSE
)

# Loop over models and modelRuns to create gridList and fakeMonitorList
gridList <- list()
fakeMonitorList <- list()
fakeAverageList <- list()

for ( i in seq_len(nrow(modelDF)) ) {
  
  modelName <- modelDF$modelName[i]
  modelRun <- modelDF$modelRun[i]
  
  # Load model data
  name <- paste0(modelName, "_", modelRun)

  result <- try({
    gridList[[name]] <-
      AirFireModeling::bluesky_load(
        modelName = modelName,
        modelRun = modelRun,
        xlim = xlim,
        ylim = ylim,
        verbose = TRUE
      )
  }, silent = TRUE)
  
  if ( "try-error" %in% class(result) ) {
    
    # bluesky_load() failed -- insert NULL
    
    logger.warn("Unable to load %s", name)
    logger.trace(toString(result))
    
    gridList[[name]] <- NULL
    fakeMonitorList[[name]] <- NULL
    fakeAverageList[[name]] <- NULL
    
  } else {
    
    # bluesky_load() succeeded -- create monitor objects
    
    result <- try({
      # Create a ws_monitor object with 'count' timeseries
      fakeMonitorList[[name]] <-
        AirFireModeling::raster_toMonitor(
          gridList[[name]],
          longitude = longitude,
          latitude = latitude,
          radius = radius,
          count = count,
          rasterName = name,
          verbose = FALSE
        )
      
      # Add modelName and modelRun to metadata
      fakeMonitorList[[name]]$meta$model <-
        ifelse(stringr::str_count(modelName) > 15,
               paste0(stringr::str_sub(modelName,1,15), "..."),
               modelName)
      fakeMonitorList[[name]]$meta$modelRun <- modelRun
      
      fakeAverageList[[name]] <- 
        monitor_collapse(
          fakeMonitorList[[name]],
          monitorID = name
        )
    })
    
    if ( "try-error" %in% class(result) ) {
      fakeMonitorList[[name]] <- NULL
      fakeAverageList[[name]] <- NULL
    }
    
  }
  
} # END of modelDF loop

# Create a single ws_monitor object
fakeMonitors <- monitor_combine(fakeMonitorList)

fakeAverages <- monitor_combine(fakeAverageList)

startdate <- "20200708"
enddate <- "20200711"
tlim <- c(startdate, enddate)

monitor_subset <- monitor_subset(fakeMonitors, tlim = tlim)

ggByModel <-
  ggplot_pm25Timeseries(
    monitor_subset,
    ylim = c(0, max(monitor_subset$data[,-1], na.rm = TRUE)),
    includeFullEnddate = TRUE
  ) +
  geom_pm25Points(aes(color = modelRun), size = .5, alpha = 0.3) +
  stat_nowcast(aes(color = modelRun), alpha = 0.3) +
  stat_meanByHour(aes(color = modelRun), geom = "line", size = 1.5) +
  facet_grid(rows = vars(model)) +
  theme(legend.position = "right") +
  theme(legend.position = "bottom") +
  ggtitle("By Model (colored by model run)")

print(ggByModel)

tlim <- c(startdate, enddate)

monitor_subset <- monitor_subset(fakeMonitors, tlim = tlim)

ggByRun <-
  ggplot_pm25Timeseries(
    monitor_subset,
    ylim = c(0, max(monitor_subset$data[,-1], na.rm = TRUE)),
    includeFullEnddate = TRUE
  ) +
  geom_pm25Points(aes(color = model), size = .5, alpha = 0.3) +
  stat_nowcast(aes(color = model), alpha = 0.3) +
  stat_meanByHour(aes(color = model), geom = "line", size = 1.5) +
  facet_grid(rows = vars(modelRun)) +
  theme(legend.position = "right") +
  theme(legend.position = "bottom") +
  ggtitle("By Model Run (colored by model)")

print(ggByRun)
```

